--- REQUIREMENTS
table.contains = function(t, e)
    if type(e) == "table" then
        for _, v in pairs(t) do
            for __, w in pairs(e) do
                if v == w then return true end
            end
        end
    else
        for _, v in pairs(t) do
            if v == e then return true end
        end
    end
    return false
end
table.containsKey = function(t, e)
    for k, _ in pairs(t) do
        if k == e then return true end
    end
    return false
end
table.getKeys = function(t)
    local t2 = {}
    for k, _ in pairs(t) do
        table.insert(t2, k)
    end
    return t2
end
table.equal = function(t1, t2)
    if #t1 == #t2 then
        for i = 1, #t1 do
            if not (t1[i] == t2[i]) then return false end
        end
        return true
    else
        return false
    end
end
local function extend(t1,t2)
   for i=1,#t2 do
      t1[#t1+1] = t2[i]
   end
   return t1
end
local function printTable(t, prefix, subPrefix)
    local text = ""
    for k, v in pairs(t) do
        if type(v) == "table" then
            text = text..prefix..tostring(k).."<\n"..printTable(v, prefix..subPrefix, subPrefix).."\n"..prefix..">\n"
        else
            text = text..prefix..tostring(k)..": "..tostring(v).."\n"
        end
    end
    return text:sub(1, #text-1)
end
local function splits(text, seps)
    if not text then error("missing argument") end
    if not seps then error("missing argument") end
    if not type(text) == "string" then error("text has to be type string") end
    if not type(seps) == "table" then error("seps has to be type table") end
    local t = {}
    local temp = ""
    for i = 1, #text do
        local c = text:sub(i,i)
        if table.contains(seps, c) then
            if temp then table.insert(t, temp); table.insert(t, c) end
            temp = ""
        else
            if #temp > 0 then temp = temp .. c else temp = c end
        end
    end
    if temp then table.insert(t, temp); table.insert(t, c) end
    temp = ""
    return t
end
local pretty = require "cc.pretty"
local argv = {...}
local PROGRAM_NAME
local version = "turt v0.1"

--- TOKENS
-- main
local function Operation(op)        return { token = "op", val = op } end
local function OpRep(op)            return { token = "opRep", val = op } end
local function Operator(val)        return { token = "operator", val = val } end
local function GetOperator(val)     return { token = "getOperator", val = val } end
-- datatypes
local function Int(val)             return { token = "int", val = math.floor(val) } end
local function Bool(val)            return { token = "bool", val = val } end
local function Direction(direction) return { token = "direction", val = direction }  end
local function Str(val)             return { token = "str", val = val } end
local function List(val)            return { token = "list", val = val}  end
local function Obj(val)             return { token = "obj", val = val}  end
local function Func(args, val)      return { token = "func", args = args, val = val } end
local function LuaFunc(args, val)   return { token = "luaFunc", args = args, func = val } end
local function Null()               return { token = "null", val = nil } end
-- other
local function Var(val)             return { token = "var", val = val } end
local function Tag(tag)             return { token = "tag", val = tag }  end
local function TagRep(val)          return { token = "tagRep", val = val } end
local function Args(val)            return { token = "args", val = val } end
local function TagArgs(val)         return { token = "tagArgs", val = val } end
-- debuging
local function ERROR(text)
    if term.isColor() then
        term.setTextColor(colors.red)
    else
        term.setTextColor(colors.white)
    end
    print(PROGRAM_NAME .. ": (op " .. tostring(L+1) .. ") " .. text)
    error()
end

local function TOSTR(value, listStartStop, stringStartStop)
    if not listStartStop then listStartStop = {"", ""} end
    if not stringStartStop then stringStartStop = {"", ""} end
    if value.token == nil then
        return Str("null")
    elseif value.token == "list" then
        local text = listStartStop[1]
        for i = 1, #value.val do
            text = text .. (TOSTR(value.val[i], listStartStop, stringStartStop)).val .. ", "
        end
        text = text .. listStartStop[2]
        return Str(text)
    elseif value.token == "dict" then
        local text = listStartStop[1]
        for k, v in pairs(value.val) do
            text = text .. "\"" .. k .. "\": " .. (TOSTR(v, listStartStop, stringStartStop)).val .. ", "
        end
        text = text .. listStartStop[2]
        return Str(text)
    elseif value.token == "obj" then
        local text = listStartStop[1]
        for k, v in pairs(value.val) do
            text = text .. k .. ": " .. (TOSTR(v, listStartStop, stringStartStop)).val .. ", "
        end
        text = text .. listStartStop[2]
        return Str(text)
    elseif value.token == "str" then
        return Str(stringStartStop[1]..tostring(value.val)..stringStartStop[2])
    else
        return Str(tostring(value.val))
    end
end

--- KEYWORDS
local NUMS = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" }
local LETTERS = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
                  'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
                  'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_' }
local LOGICS = { "true", "false" }

local GETTYPES = { "int", "bool", "list", "dict", "obj", "str", "direction", "null", "func", "luaFunc", "opRep" }
local OPERATORS = { "write", "print", "move", "turn", "repeat", "while", "var", "set", "inc", "dec", "if", "else",
                    "move", "fmove", "dig", "fdig", "place", "fplace", "attack", "fattack", "drop", "suck", "select",
                    "turn", "wait", "DEBUG_TAGS", "do"}
local DIRECTIONS = { "forward", "back", "up", "down", "left", "right" }
local GetOperators = {
    ["+"] = {
        { type = "infinite", syntax = { "int" }, func = function(args)
            local sum = args[1].val
            if #args > 1 then
                for i = 2, #args do
                    sum = sum + args[i].val
                end
            end
            return Int(sum)
        end }
    },
    ["-"] = {
        { type = "infinite", syntax = { "int" }, func = function(args)
            local sum = args[1].val
            if #args > 1 then
                for i = 2, #args do
                    sum = sum - args[i].val
                end
            else
                sum = -sum
            end
            return Int(sum)
        end }
    },
    ["*"] = {
        { type = "infinite", syntax = { "int" }, func = function(args)
            local sum = args[1].val
            if #args > 1 then
                for i = 2, #args do
                    sum = sum * args[i].val
                end
            end
            return Int(sum)
        end }
    },
    ["pow"] = {
        { type = "finite", syntax = { { "int" }, { "int" } }, func = function(args)
            local prod = 1
            for i = 1, args[2].val do
                prod = prod * args[1].val
            end
            return Int(prod)
        end }
    },
    ["abs"] = {
        { type = "finite", syntax = { { "int" } }, func = function(args)
            return Int(math.abs(args[1].val))
        end }
    },
    ["int"] = {
        { type = "finite", syntax = { { "int" } }, func = function(args)
            return args[1]
        end },
        { type = "finite", syntax = { { "bool" } }, func = function(args)
            if args[1].val then return Int(1) else return Int(0) end
        end },
        { type = "finite", syntax = { { "str" } }, func = function(args)
            if #args[1].val > 0 then
                local allowed = true
                for i = 1, #args[1].val do if not table.contains(NUMS, args[1].val:sub(i,i)) then allowed = false; break end end
                if allowed then return Int(tonumber(args[1].val))
                else ERROR("cannot do getOperation int on str \""..tostring(args[1].val).."\"") end
            else ERROR("cannot do getOperation int on str \""..tostring(args[1].val).."\"") end
        end }
    },
    ["str"] = {
        { type = "finite", syntax = { { "int", "bool", "str" } }, func = function(args)
            return Str(tostring(args[1].val))
        end },
    },
    ["bool"] = {
        { type = "finite", syntax = { { "int" } }, func = function(args)
            return Bool(not (args[1].val == 0))
        end },
        { type = "finite", syntax = { { "bool" } }, func = function(args)
            return args[1]
        end }
    },
    ["not"] = {
        { type = "finite", syntax = { { "bool" } }, func = function(args)
            return Bool(not args[1].val)
        end }
    },
    ["eq"] = {
        { type = "finite", syntax = { { "bool", "int" }, { "bool", "int" } }, func = function(args)
            return Bool(args[1].val == args[2].val)
        end },
        { type = "finite", syntax = { { "str" }, { "str" } }, func = function(args)
            return Bool(args[1].val == args[2].val)
        end },
    },
    ["nEq"] = {
        { type = "finite", syntax = { { "bool", "int" }, { "bool", "int" } }, func = function(args)
            return Bool(not(args[1].val == args[2].val))
        end },
        { type = "finite", syntax = { { "str" }, { "str" } }, func = function(args)
            return Bool(not(args[1].val == args[2].val))
        end },
    },
    ["big"] = {
        { type = "finite", syntax = { { "int" }, { "int" } }, func = function(args)
            return Bool(args[1].val > args[2].val)
        end },
    },
    ["less"] = {
        { type = "finite", syntax = { { "int" }, { "int" } }, func = function(args)
            return Bool(args[1].val < args[2].val)
        end },
    },
    ["bEq"] = {
        { type = "finite", syntax = { { "int" }, { "int" } }, func = function(args)
            return Bool(args[1].val >= args[2].val)
        end },
    },
    ["lEq"] = {
        { type = "finite", syntax = { { "int" }, { "int" } }, func = function(args)
            return Bool(args[1].val <= args[2].val)
        end },
    },
    ["and"] = {
        { type = "finite", syntax = { { "bool" }, { "bool" } }, func = function(args)
            return Bool(args[1].val and args[2].val)
        end },
    },
    ["or"] = {
        { type = "finite", syntax = { { "bool" }, { "bool" } }, func = function(args)
            return Bool(args[1].val or args[2].val)
        end },
    },
    ["len"] = {
        { type = "finite", syntax = { { "list" } }, func = function(args)
            return Int(#args[1].val)
        end },
        { type = "finite", syntax = { { "str" } }, func = function(args)
            return Int(#args[1].val)
        end },
    },
    ["con"] = {
        { type = "infinite", syntax = { "str" }, func = function(args)
            local text = args[1].val
            if #args > 1 then
                for i = 2, #args do
                    text = text .. args[i].val
                end
            end
            return Str(text)
        end },
    },
    ["input"] = {
        { type = "finite", syntax = { { "str" } }, func = function(args)
            write(args[1].val)
            return Str(read())
        end },
        { type = "finite", syntax = {}, func = function(args)
            return Str(read())
        end },
    },
    ["randint"] = {
        { type = "finite", syntax = { { "int" }, { "int" } }, func = function(args)
            return Int(math.random(args[1].val, args[2].val))
        end },
        { type = "finite", syntax = { { "int" } }, func = function(args)
            return Int(math.random(args[1].val-1))
        end },
    },
    ["func"] = {
        { type = "finite", syntax = { { "tagArgs" }, { "opRep" } }, func = function(args)
            return Func(args[1].val, args[2].val)
        end },
        { type = "finite", syntax = { { "opRep" } }, func = function(args)
            return Func(Args({}), args[1].val)
        end },
    },
}
local GETOPERATORS = table.getKeys(GetOperators)
local VARS = { "TIME" }
local TAG_IDENTIFIERS = { "@" }
local TAGREP_IDENTIFIERS = { "." }
local TAG_TYPES = { "op", "int", "bool", "str", "list" }
local OP_STARTS = { "<" }
local OP_ENDS = { ">" }
local OPREP_STARTS = { "{" }
local OPREP_ENDS = { "}" }
local COLLECTION_STARTS = { "[" }
local COLLECTION_ENDS = { "]" }
local ARGS_STARTS = { "(" }
local ARGS_ENDS = { ")" }
local SEPERATORS = { "," }
local STR_QOUTATIONS = { "\"" }
local OP_SEPS = { "\n", ";" }
local COMMENTS = { "#" }
local IGNORES = { "", " ", "\t" }
local ALL = { "true", "false" }
extend(ALL, OPERATORS)
extend(ALL, DIRECTIONS)
extend(ALL, OP_STARTS)
extend(ALL, OP_ENDS)
extend(ALL, OPREP_STARTS)
extend(ALL, OPREP_ENDS)
extend(ALL, COLLECTION_STARTS)
extend(ALL, COLLECTION_ENDS)
extend(ALL, ARGS_STARTS)
extend(ALL, ARGS_ENDS)
extend(ALL, SEPERATORS)
extend(ALL, GETOPERATORS)
extend(ALL, VARS)
extend(ALL, TAG_IDENTIFIERS)
extend(ALL, TAGREP_IDENTIFIERS)
extend(ALL, TAG_TYPES)
extend(ALL, STR_QOUTATIONS)
extend(ALL, OP_SEPS)
extend(ALL, COMMENTS)
extend(ALL, IGNORES)

--- INTERPRETER
tags = {
    term = { val = Obj({
        clear = LuaFunc(Args({}), function()
            term.clear()
            return Null()
        end),
        getSize = LuaFunc(Args({}), function()
            local w, h = term.getSize()
            return List({ Int(w), Int(h) })
        end),
        setBackgroundColor = LuaFunc(TagArgs({ TagRep("color") }), function(args)
            pretty.pretty_print(args.val)
            if args.token == "args" then
                if args.val[1] then
                    if args.val[1].token == "int" then
                        term.setBackgroundColor(args.val[1].val)
                        return Null()
                    else ERROR("expected int, got "..args.val[1].token) end
                else ERROR("missing argument") end
            else ERROR("expected args, got "..args.token) end
        end),
        setTextColor = LuaFunc(TagArgs({ TagRep("color") }), function(args)
            if args.token == "args" then
                if args.val[1] then
                    if args.val[1].token == "int" then
                        term.setTextColor(args.val[1].val)
                        return Null()
                    else ERROR("expected int, got "..args[1].token) end
                else ERROR("missing argument") end
            else ERROR("expected args, got "..args.token) end
        end),
    }) },
    colors = { val = Obj({
        white = Int(colors.white),
        black = Int(colors.black),
        gray = Int(colors.gray),
        lightGray = Int(colors.lightGray),
    }) }
}
L = 0
function getToken(token)
    if token then
        if token.token == "tag" then
            if tags then
                if tags[token.val] then
                    return tags[token.val].val
                else ERROR("tag not registered") end
            else ERROR("tag not registered") end
        end
        if token.token == "getOp" then
            local t = getOperation(token.val)
            return t
        end
        if token.token == "op" then
            local t, _ = operate(token)
            return t
        end
        if token.token == "var" then
            if token.val == "TIME" then return Int(os.time()*1000) end
            ERROR("unrecognized var")
        end
        if token.token == "tagRep" then return token end
        if token.token == "tagArgs" then return token end
        if token.token == "args" then return token end
        if table.contains(GETTYPES, token.token) then return token end
        ERROR("invalid token to get ("..tostring(token.token)..")")
    else return Null() end
end
function getOperation(op)
    op = op[1]
    if op[1].token == "getOperator" then
        local args = {}
        for i = 2, #op do
            table.insert(args, getToken(op[i]))
        end
        local map = {}
        for _, t in pairs(args) do
            table.insert(map, t.token)
        end
        for k, v in pairs(GetOperators) do
            if tostring(k) == tostring(op[1].val) then
                for _, reg in pairs(v) do
                    if reg.type == "infinite" then
                        local ok = true
                        for i = 1, #map do
                            if not (table.contains(reg.syntax, map[i])) then
                                ok = false
                                break
                            end
                        end
                        if ok then return reg.func(args) end
                    elseif reg.type == "finite" then
                        if #map == #reg.syntax then
                            local ok = true
                            for i = 1, #reg.syntax do
                                if not (table.contains(reg.syntax[i], map[i])) then
                                    ok = false
                                    break
                                end
                            end
                            if ok then return reg.func(args) end
                        end
                    end
                end
                if v.type == "finite" then
                    local pattern = "["
                    for i = 1, #map do pattern = pattern .. map[i] .. " " end
                    pattern = pattern:sub(1, #pattern-1) .. "]"
                    ERROR("argument pattern "..pattern.." is not valid for "..op[1].val)
                else
                    local pattern = "["
                    for i = 1, #map do pattern = pattern .. map[i] .. " " end
                    pattern = pattern:sub(1, #pattern-1) .. "]"
                    ERROR("argument pattern "..pattern.." invalid for "..op[1].val)
                end
            end
        end
        ERROR("unrecognized getOperator "..tostring(op[1].val))
    else ERROR("expected getOperator, got "..tostring(op[1].token)) end
end
function getVar(var)
    if var == "TIME" then return Int(math.floor(os.time() * 1000)) end
    ERROR("unrecognized global tag")
end
function indexToken(token, indexToken)
    local index = getToken(indexToken)
    if token.token == "list" then
        if index.token == "int" then
            return token.val[index.val+1]
        else ERROR("expected int, got "..index.token) end
    elseif token.token == "dict" then
        if index.token == "str" then
            return token.val[index.val]
        else ERROR("expected str, got "..index.token) end
    elseif token.token == "obj" then
        if index.token == "tagRep" then
            return token.val[index.val]
        else ERROR("expected tagRep, got "..index.token) end
    elseif token.token == "str" then
        if index.token == "int" then
            return Str(token.val:sub(index.val+1, index.val+1))
        else ERROR("expected tagRep, got "..index.token) end
    elseif token.token == "func" then
        if index.token == "args" then
            local delete_tags = {}
            for i = 1, #token.args do
                if index.val[i] then
                    tags[token.args[i].val] = { val = getToken(index.val[i]) }
                else
                    tags[token.args[i].val] = { val = Null() }
                end
                table.insert(delete_tags, token.args[i].val)
            end
            local _returnToken, _ = operate(token)
            for _, tag in ipairs(delete_tags) do tags[tag] = nil end
            if _returnToken then return _returnToken else return Null() end
        else ERROR("expected args, got "..index.token) end
    elseif token.token == "luaFunc" then
        if index.token == "args" then
            local args = {}
            for i = 1, #token.args do
                if index.val[i] then
                    table.insert(args, getToken(index.val[i]))
                else
                    table.insert(args, Null())
                end
            end
            local _returnToken, _ = token.func(Args(args))
            if _returnToken then return _returnToken else return Null() end
        else ERROR("expected args, got "..index.token) end
    else
        ERROR("cannot index "..token.token.." with "..index.token)
    end
end
function operate(op)
    local delete_tags = {}
    local returnToken = Null()
    local returns = false
    for _, line in pairs(op.val) do
        if #line > 0 then
            if line[1].token == "operator" then

                if line[1].val == "write" then
                    local args = {}
                    for i = 2, #line do table.insert(args, getToken(line[i])) end
                    local map = {}
                    for _, t in pairs(args) do table.insert(map, t.token) end
                    if #map == 1 then
                        write(TOSTR(args[1]).val)
                    end

                elseif line[1].val == "print" then
                    local args = {}
                    for i = 2, #line do table.insert(args, getToken(line[i])) end
                    local map = {}
                    for _, t in pairs(args) do table.insert(map, t.token) end
                    if #map == 1 then
                        print(TOSTR(args[1]).val)
                    end

                elseif line[1].val == "move" then
                    local args = {}
                    for i = 2, #line do table.insert(args, getToken(line[i])) end
                    local map = {}
                    for _, t in pairs(args) do table.insert(map, t.token) end
                    if turtle then
                        if map[1] == "direction" then
                            local force = false
                            if map[2] == "bool" then
                                force = args[2].val
                            end
                            local success
                            while not success do
                                if args[1].val == "forward" then success = turtle.forward()
                                elseif args[1].val == "back" then success = turtle.back()
                                elseif args[1].val == "up" then success = turtle.up()
                                elseif args[1].val == "down" then success = turtle.down()
                                else ERROR("invalid direction for move, "..tostring(args[1].val)) end
                                if not force then break end
                            end
                        else ERROR("expected direction, got "..tostring(args[1].token)) end
                    else ERROR("move operator is not valid for this device") end

                elseif line[1].val == "dig" then
                    if turtle then
                        local t = getToken(line[2])
                        local side
                        if #line > 2 then
                            local t2 = getToken(line[3])
                            if t2.token == "direction" then if table.contains({"left", "right"}, t2.val) then side = t2.val
                            else ERROR("invalid side for dig, "..tostring(t.val)) end
                            else ERROR("expected direction, got "..tostring(t2.token)) end
                        end
                        if t.token == "direction" then
                            if t.val == "forward" then turtle.dig(side)
                            elseif t.val == "up" then turtle.digUp(side)
                            elseif t.val == "down" then turtle.digDown(side)
                            else ERROR("invalid direction for dig, "..tostring(t.val)) end
                        else ERROR("expected direction, got "..tostring(t.token)) end
                    else ERROR("dig operator is not valid for this device") end

                elseif line[1].val == "place" then
                    if turtle then
                        local t = getToken(line[2])
                        local text
                        if #line > 2 then
                            local t2 = getToken(line[3])
                            if t2.token == "str" then text = t2.val
                            else ERROR("expected str, got"..tostring(t2.token)) end
                        end
                        if t.token == "direction" then
                            if t.val == "forward" then turtle.place(text)
                            elseif t.val == "up" then turtle.placeUp(text)
                            elseif t.val == "down" then turtle.placeDown(text)
                            else ERROR("invalid direction for place, "..tostring(t.val)) end
                        else ERROR("expected direction, got "..tostring(t.token)) end
                    else ERROR("place operator is not valid for this device") end

                elseif line[1].val == "attack" then
                    if turtle then
                        local t = getToken(line[2])
                        local side
                        if #line > 2 then
                            local t2 = getToken(line[3])
                            if t2.token == "direction" then if table.contains({"left", "right"}, t2.val) then side = t2.val
                            else ERROR("invalid side for attack, "..tostring(t.val)) end
                            else ERROR("expected direction, got "..tostring(t2.token)) end
                        end
                        if t.token == "direction" then
                            if t.val == "forward" then turtle.attack(side)
                            elseif t.val == "up" then turtle.attackUp(side)
                            elseif t.val == "down" then turtle.attackDown(side)
                            else ERROR("invalid direction for attack, "..tostring(t.val)) end
                        else ERROR("expected direction, got "..tostring(t.token)) end
                    else ERROR("attack operator is not valid for this device") end

                elseif line[1].val == "drop" then
                    if turtle then
                        local t = getToken(line[2])
                        local count
                        if #line > 2 then
                            local t2 = getToken(line[3])
                            if t2.token == "int" then count = t2.val
                            else ERROR("expected int, got"..tostring(t2.token)) end
                        end
                        if t.token == "direction" then
                            if t.val == "forward" then turtle.drop(count)
                            elseif t.val == "up" then turtle.dropUp(count)
                            elseif t.val == "down" then turtle.dropDown(count)
                            else ERROR("invalid direction for drop, "..tostring(t.val)) end
                        else ERROR("expected direction, got "..tostring(t.token)) end
                    else ERROR("drop operator is not valid for this device") end

                elseif line[1].val == "suck" then
                    if turtle then
                        local t = getToken(line[2])
                        local count
                        if #line > 2 then
                            local t2 = getToken(line[2])
                            if t2.token == "int" then count = t2.val
                            else ERROR("expected int, got"..tostring(t2.token)) end
                        end
                        if t.token == "direction" then
                            if t.val == "forward" then turtle.suck(count)
                            elseif t.val == "up" then turtle.suckUp(count)
                            elseif t.val == "down" then turtle.suckDown(count)
                            else ERROR("invalid direction for suck, "..tostring(t.val)) end
                        else ERROR("expected direction, got "..tostring(t.token)) end
                    else ERROR("suck operator is not valid for this device") end

                elseif line[1].val == "select" then
                    if turtle then
                        local t = getToken(line[2])
                        if t.token == "int" then
                            turtle.select(t.val)
                        else ERROR("expected int, got "..tostring(t.token)) end
                    else ERROR("select operator is not valid for this device") end

                elseif line[1].val == "turn" then
                    if turtle then
                        local t = getToken(line[2])
                        if t.token == "direction" then
                            if t.val == "right" then turtle.turnRight()
                            elseif t.val == "left" then turtle.turnLeft()
                            else ERROR("invalid direction for turn, "..tostring(t.val)) end
                        else ERROR("expected direction, got "..tostring(t.token)) end
                    else ERROR("turn operator is not valid for this device") end

                elseif line[1].val == "var" then
                    -- local tag
                    if line[2].token == "tag" then
                        local t = getToken(line[3])
                        tags[line[2].val] = { val = t }
                        table.insert(delete_tags, line[2].val)
                    else ERROR("expected tag, got "..tostring(line[2].token)) end

                elseif line[1].val == "set" then
                    -- global tag
                    if line[2].token == "tag" then
                        local t = getToken(line[3])
                        tags[line[2].val] = { val = t }
                    else ERROR("expected tag, got "..tostring(line[2].token)) end

                elseif line[1].val == "repeat" then
                    -- repeat loop
                    if line[2] then
                        local t = getToken(line[2])
                        if t.token == "int" then
                            if line[3] then
                                if line[3].token == "op" then
                                    local returnToken_, return_
                                    for _ = 1, t.val do
                                        returnToken_, return_ = operate(line[3])
                                        if return_ then
                                            break
                                        end
                                    end
                                    if return_ then
                                        returnToken = returnToken_
                                        returns = true
                                        break
                                    end
                                else ERROR("expected op, got "..tostring(line[3].token)) end
                            else ERROR("missing argument") end
                        else ERROR("expected int, got "..tostring(t.token)) end
                    else ERROR("missing argument") end

                elseif line[1].val == "while" then
                    -- while loop
                    if line[2] then
                        local t1 = getToken(line[2])
                        if t1.token == "bool" then
                            if line[3] then
                                if line[3].token == "op" then
                                    while t1.val do
                                        local return_
                                        _, return_ = operate(line[3])
                                        t1 = getToken(line[2])
                                    end
                                else ERROR("expected op, got "..tostring(line[3].token)) end
                            else ERROR("missing argument") end
                        else ERROR("expected bool, got "..tostring(t1.token)) end
                    else ERROR("missing argument") end

                elseif line[1].val == "if" then
                    -- while loop
                    if line[2] then
                        local t1 = getToken(line[2])
                        if t1.token == "bool" then
                            if line[3] then
                                if line[3].token == "op" then
                                    if t1.val then
                                        local return_ = false
                                        local returnToken_
                                        returnToken_, return_ = operate(line[3])
                                        if return_ then
                                            returnToken = returnToken_
                                            returns = true
                                            break
                                        end
                                    else
                                        if line[4] then
                                            if line[4].token == "operator" then
                                                if line[4].val == "else" then
                                                    if line[5] then
                                                        if line[5].token == "op" then
                                                            local return_ = false
                                                            local returnToken_
                                                            returnToken_, return_ = operate(line[5])
                                                            if return_ then
                                                                returnToken = returnToken_
                                                                returns = true
                                                                break
                                                            end
                                                        else ERROR("expected op, got "..tostring(line[5].token)) end
                                                    else ERROR("missing argument") end
                                                else ERROR("expected else, got "..tostring(line[4].val)) end
                                            else ERROR("expected operator, got "..tostring(line[4].token)) end
                                        end
                                    end
                                else ERROR("expected op, got "..tostring(line[3].token)) end
                            else ERROR("missing argument") end
                        else ERROR("expected bool, got "..tostring(t1.token)) end
                    else ERROR("missing argument") end

                elseif line[1].val == "inc" then
                    -- increment int
                    if line[2] then
                        if line[2].token == "tag" then
                            if tags[line[2].val] then
                                if tags[line[2].val].val.token == "int" then
                                    tags[line[2].val].val = Int(tags[line[2].val].val.val + 1)
                                else ERROR("cannot inc type "..tags[line[2].val].val) end
                            else ERROR("tag not registered") end
                            -- pretty.pretty_print(tags[line[2].val].token)
                        else ERROR("expected tag, got "..tostring(line[2].token)) end
                    else ERROR("missing argument") end

                elseif line[1].val == "dec" then
                    -- decrement int
                    if line[2] then
                        if line[2].token == "tag" then
                            if tags[line[2].val] then
                                if tags[line[2].val].val.token == "int" then
                                    tags[line[2].val].val = Int(tags[line[2].val].val.val - 1)
                                else ERROR("cannot inc type "..tags[line[2].val].val) end
                            else ERROR("tag not registered") end
                            -- pretty.pretty_print(tags[line[2].val].token)
                        else ERROR("expected tag, got "..tostring(line[2].token)) end
                    else ERROR("missing argument") end

                elseif line[1].val == "wait" then
                    -- wait x times or wait until condition is true
                    if line[2] then
                        local t = getToken(line[2])
                        if t.token == "int" then
                            sleep(t.val)
                        elseif t.token == "bool" then
                            while not t.val do t = getToken(line[2]) end
                        else ERROR("expected int or bool, got"..tostring(t.token)) end
                    else ERROR("missing argument") end

                elseif line[1].val == "DEBUG_TAGS" then
                    print("")
                    if line[2] then
                        if line[2].token == "tag" then
                            pretty.pretty_print(tags[line[2].val].val)
                        else ERROR("expected tag, got "..tostring(line[2].token)) end
                    else
                        pretty.pretty_print(tags)
                    end
                    print("")

                else ERROR("unrecognized operator \""..tostring(line[1].val).."\"") end
            elseif line[1].token == "tag" then
                returnToken = getToken(line[1])
                if line[2] then returnToken = indexToken(returnToken, line[2]) end
                returns = true
                break

            elseif line[1].token == "getOperator" then
                returnToken = getOperation({ line })
                returns = true
                break

            elseif line[1].token == "var" then
                returnToken = getVar(line[1].val)
                returns = true
                break

            elseif line[1].token == "op" then
                returnToken, _ = operate(line[1])
                if line[2] then returnToken = indexToken(returnToken, line[2]) end
                returns = true
                break

            elseif table.contains(GETTYPES, line[1].token) then
                returnToken = line[1]
                if line[2] then returnToken = indexToken(returnToken, line[2]) end
                returns = true
                break

            else ERROR("expected tag, getOperator, var or type, got "..tostring(line[1].token)) end
        end
        L = L + 1
    end
    for i, tag in ipairs(delete_tags) do
        tags[tag] = nil
    end
    return returnToken, returns
end

--- TOKENIZER
function tokenizeArgs(raw)
    local list = {}
    table.insert(list, {})
    local index = 1
    local line = 1
    while index <= #raw do
        if table.contains(OPERATORS, raw[index]) then table.insert(list[line], Operator(raw[index]))

        elseif table.contains(DIRECTIONS, raw[index]) then table.insert(list[line], Direction(raw[index]))

        elseif table.contains(LOGICS, raw[index]) then table.insert(list[line], Bool((raw[index] == "true")))

        elseif table.contains(NUMS, raw[index]:sub(1,1)) then table.insert(list[line], Int(tonumber(raw[index])))

        elseif table.contains(GETOPERATORS, raw[index]) then table.insert(list[line], GetOperator(raw[index]))

        elseif table.contains(STR_QOUTATIONS, raw[index]) then
            local raw_str = ""
            index = index + 1
            while not (raw[index] == "\"") and index <= #raw do
                raw_str = raw_str .. raw[index]
                index = index + 1
            end
            table.insert(list[line], Str(raw_str))

        elseif table.contains(OP_STARTS, raw[index]) then
            local count = 1
            local raw_op = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(OP_STARTS, raw[index]) then count = count + 1 end
                if table.contains(OP_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_op, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], Operation(tokenize(raw_op)))

        elseif table.contains(OPREP_STARTS, raw[index]) then
            local count = 1
            local raw_op = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(OPREP_STARTS, raw[index]) then count = count + 1 end
                if table.contains(OPREP_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_op, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], OpRep(tokenize(raw_op)))

        elseif table.contains(COLLECTION_STARTS, raw[index]) then
            local count = 1
            local raw_list = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(COLLECTION_STARTS, raw[index]) then count = count + 1 end
                if table.contains(COLLECTION_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_list, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], tokenizeCollection(raw_list))

        elseif table.contains(ARGS_STARTS, raw[index]) then
            local count = 1
            local raw_list = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(ARGS_STARTS, raw[index]) then count = count + 1 end
                if table.contains(ARGS_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_list, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], tokenizeArgs(raw_list))

        elseif table.contains(SEPERATORS, raw[index]) then
            if list[line] then if #list[line] > 0 then
                    line = line + 1
                    table.insert(list, {})
            end end

        elseif table.contains(VARS, raw[index]) then table.insert(list[line], Var(raw[index]))

        elseif table.contains(TAG_IDENTIFIERS, raw[index]) then
            index = index + 1
            if table.contains(LETTERS, raw[index]:sub(1,1)) then
                table.insert(list[line], Tag(raw[index]))
            else ERROR("forbidden character for tag") end

        elseif table.contains(TAGREP_IDENTIFIERS, raw[index]) then
            index = index + 1
            if table.contains(LETTERS, raw[index]:sub(1,1)) then
                table.insert(list[line], TagRep(raw[index]))
            else ERROR("forbidden character for tag") end

        elseif table.contains(IGNORES, raw[index]) or table.contains(OP_SEPS, raw[index]) then

        else ERROR("unidentified token \"" .. tostring(raw[index]) .. "\"") end

        index = index + 1
    end
    if list then
        if list[1] then
            if list[1][1] then
                if list[1][1].token == "tagRep" then
                    local tagArgs = {}
                    for i = 1, #list do
                        if list[i][1] then if list[i][1].token == "tagRep" then
                        else ERROR("expected tagRep, got "..list[i][1].token) end else ERROR("missing argument") end
                        table.insert(tagArgs, list[i][1])
                    end
                    return TagArgs(tagArgs)
                end
                if table.contains(GETTYPES, list[1][1].token) or table.contains({"tag", "op"}, list[1][1].token) then
                    local args = {}
                    for i = 1, #list do
                        if list[i][1] then if table.contains(GETTYPES, list[1][1].token) or table.contains({"tag", "op"}, list[1][1].token) then
                        else ERROR("expected getType, got "..list[i][1].token) end else ERROR("missing argument") end
                        table.insert(args, list[i][1])
                    end
                    return Args(args)
                end
            else
                return Args({})
            end
            ERROR("no collection type matching pattern")
        else ERROR("missing argument") end
    else
        return Args({})
    end
end
function tokenizeCollection(raw)
    local list = {}
    table.insert(list, {})
    local index = 1
    local line = 1
    while index <= #raw do
        if table.contains(OPERATORS, raw[index]) then table.insert(list[line], Operator(raw[index]))

        elseif table.contains(DIRECTIONS, raw[index]) then table.insert(list[line], Direction(raw[index]))

        elseif table.contains(LOGICS, raw[index]) then table.insert(list[line], Bool((raw[index] == "true")))

        elseif table.contains(NUMS, raw[index]:sub(1,1)) then table.insert(list[line], Int(tonumber(raw[index])))

        elseif table.contains(GETOPERATORS, raw[index]) then table.insert(list[line], GetOperator(raw[index]))

        elseif table.contains(STR_QOUTATIONS, raw[index]) then
            local raw_str = ""
            index = index + 1
            while not (raw[index] == "\"") and index <= #raw do
                raw_str = raw_str .. raw[index]
                index = index + 1
            end
            table.insert(list[line], Str(raw_str))

        elseif table.contains(OP_STARTS, raw[index]) then
            local count = 1
            local raw_op = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(OP_STARTS, raw[index]) then count = count + 1 end
                if table.contains(OP_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_op, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], Operation(tokenize(raw_op)))

        elseif table.contains(OPREP_STARTS, raw[index]) then
            local count = 1
            local raw_op = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(OPREP_STARTS, raw[index]) then count = count + 1 end
                if table.contains(OPREP_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_op, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], OpRep(tokenize(raw_op)))

        elseif table.contains(COLLECTION_STARTS, raw[index]) then
            local count = 1
            local raw_list = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(COLLECTION_STARTS, raw[index]) then count = count + 1 end
                if table.contains(COLLECTION_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_list, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], tokenizeCollection(raw_list))

        elseif table.contains(ARGS_STARTS, raw[index]) then
            local count = 1
            local raw_list = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(ARGS_STARTS, raw[index]) then count = count + 1 end
                if table.contains(ARGS_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_list, raw[index]) end
                index = index + 1
            end
            table.insert(list[line], tokenizeCollection(raw_list))

        elseif table.contains(SEPERATORS, raw[index]) then
            if list[line] then if #list[line] > 0 then
                    line = line + 1
                    table.insert(list, {})
            end end

        elseif table.contains(VARS, raw[index]) then table.insert(list[line], Var(raw[index]))

        elseif table.contains(TAG_IDENTIFIERS, raw[index]) then
            index = index + 1
            if table.contains(LETTERS, raw[index]:sub(1,1)) then
                table.insert(list[line], Tag(raw[index]))
            else ERROR("forbidden character for tag") end

        elseif table.contains(TAGREP_IDENTIFIERS, raw[index]) then
            index = index + 1
            if table.contains(LETTERS, raw[index]:sub(1,1)) then
                table.insert(list[line], TagRep(raw[index]))
            else ERROR("forbidden character for tag") end

        elseif table.contains(IGNORES, raw[index]) or table.contains(OP_SEPS, raw[index]) then

        else ERROR("unidentified token \"" .. tostring(raw[index]) .. "\"") end

        index = index + 1
    end
    if list then
        if list[1] then
            if list[1][1].token == "tagRep" then
                if list[1][2] then if table.contains(GETTYPES, list[1][2].token) then
                    local obj = {}
                    for i = 1, #list do
                        if list[i][1] then if list[i][1].token == "tagRep" then else ERROR("expected tagRep, got "..list[i][1].token) end else ERROR("missing argument") end
                        if list[i][2] then if table.contains(GETTYPES, list[i][2].token) then else ERROR("expected getType, got "..list[i][2].token) end else ERROR("missing argument") end
                        obj[list[i][1].val] = list[i][2]
                    end
                    return Obj(obj)
                end end
            end
            if table.contains(GETTYPES, list[1][1].token) then
                local _list = {}
                for i = 1, #list do
                    if list[i][1] then if table.contains(GETTYPES, list[i][1].token) then else ERROR("expected getType, got "..list[i][1].token) end else ERROR("missing argument") end
                    table.insert(_list, list[i][1])
                end
                return List(_list)
            end
            ERROR("no collection type matching pattern")
        else ERROR("missing argument") end
    else
        return List({})
    end
end
function tokenize(raw)
    local op = {}
    table.insert(op, {})
    local index = 1
    local line = 1
    while index <= #raw do
        if table.contains(OPERATORS, raw[index]) then table.insert(op[line], Operator(raw[index]))

        elseif table.contains(DIRECTIONS, raw[index]) then table.insert(op[line], Direction(raw[index]))

        elseif table.contains(LOGICS, raw[index]) then table.insert(op[line], Bool((raw[index] == "true")))

        elseif table.contains(NUMS, raw[index]:sub(1,1)) then table.insert(op[line], Int(tonumber(raw[index])))

        elseif table.contains(GETOPERATORS, raw[index]) then table.insert(op[line], GetOperator(raw[index]))

        elseif table.contains(STR_QOUTATIONS, raw[index]) then
            local raw_str = ""
            index = index + 1
            while not (raw[index] == "\"") and index <= #raw do
                raw_str = raw_str .. raw[index]
                index = index + 1
            end
            table.insert(op[line], Str(raw_str))

        elseif table.contains(OP_STARTS, raw[index]) then
            local count = 1
            local raw_op = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(OP_STARTS, raw[index]) then count = count + 1 end
                if table.contains(OP_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_op, raw[index]) end
                index = index + 1
            end
            table.insert(op[line], Operation(tokenize(raw_op)))

        elseif table.contains(OPREP_STARTS, raw[index]) then
            local count = 1
            local raw_op = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(OPREP_STARTS, raw[index]) then count = count + 1 end
                if table.contains(OPREP_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_op, raw[index]) end
                index = index + 1
            end
            table.insert(op[line], OpRep(tokenize(raw_op)))

        elseif table.contains(COLLECTION_STARTS, raw[index]) then
            local count = 1
            local raw_list = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(COLLECTION_STARTS, raw[index]) then count = count + 1 end
                if table.contains(COLLECTION_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_list, raw[index]) end
                index = index + 1
            end
            table.insert(op[line], tokenizeCollection(raw_list))

        elseif table.contains(ARGS_STARTS, raw[index]) then
            local count = 1
            local raw_list = {}
            index = index + 1
            while count > 0 and index <= #raw do
                if table.contains(ARGS_STARTS, raw[index]) then count = count + 1 end
                if table.contains(ARGS_ENDS, raw[index]) then count = count - 1 end
                if count > 0 then table.insert(raw_list, raw[index]) end
                index = index + 1
            end
            table.insert(op[line], tokenizeArgs(raw_list))

        elseif table.contains(COMMENTS, raw[index]) then
            if op[line] then if #op[line] > 0 then
                    line = line + 1
                    table.insert(op, {})
            end end
            while not table.contains(OP_SEPS, raw[index]) do index = index + 1 end

        elseif table.contains(OP_SEPS, raw[index]) then
            if op[line] then if #op[line] > 0 then
                    line = line + 1
                    table.insert(op, {})
            end end

        elseif table.contains(VARS, raw[index]) then table.insert(op[line], Var(raw[index]))

        elseif table.contains(TAG_IDENTIFIERS, raw[index]) then
            index = index + 1
            if table.contains(LETTERS, raw[index]:sub(1,1)) then
                table.insert(op[line], Tag(raw[index]))
            else ERROR("forbidden character for tag") end

        elseif table.contains(TAGREP_IDENTIFIERS, raw[index]) then
            index = index + 1
            if table.contains(LETTERS, raw[index]:sub(1,1)) then
                table.insert(op[line], TagRep(raw[index]))
            else ERROR("forbidden character for tag") end

        elseif table.contains(IGNORES, raw[index]) then

        else ERROR("unidentified token \"" .. tostring(raw[index]) .. "\"") end

        index = index + 1
    end
    return op
end

--- MAIN
if argv[1] then
    if argv[1] == "-update" or argv[1] == "-u" then
        print("updating turt")
        if fs.exists("turt") then fs.delete("turt") end
        shell.run("pastebin get 3cU17s8j turt")
        print("turt is now updated")
    elseif argv[1] == "-version" or argv[1] == "-v" then
        print(version)
    else
        local file = fs.open(argv[1], "r")
        PROGRAM_NAME = argv[1]
        local raw = splits(file.readAll(), ALL)
        if table.contains(raw, ALL) then
            local mainOp = Operation(tokenize(raw))
            local exitToken, returns = operate(mainOp)
            print("")
            if returns then
                if exitToken then
                    term.setTextColor(colors.gray)
                    write("exit: ")
                    term.setTextColor(colors.white)
                    print(TOSTR(exitToken, {"[ ", "]"}, {'"', '"'}).val)
                else
                    term.setTextColor(colors.gray)
                    print('returns true but exitToken is "nil" or "false"')
                end
            end
        else
            print("you sure this is a turt program?")
        end
    end
else
    print("TURT usage:\nturt -u(pdate) - updates turt\nturt <file name> - runs turt file")
end